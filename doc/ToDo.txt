quicker rendering
	can use point sprites but then they must all use the same size

To make not being able to use member vars in functions more logical, maybe remove functions from emitter
scope?  There's no real reason they should be there.  Also means that different emitters can use the same
function, ie behaviour, for an emitted objects.
	FireTypeControl needs its own max-locals count to be passed to DeepMemoryPool, this should be the
	max locals of all functions.  Currently FireTypeControls are stored per-EmitterDefinition which is fine
	but they must take their own value for maxlocals rather than use the combined emitter/function one.
	
	This will mean moving affectors out as well, but that is ok because they can't use member variables 
	anyway...or can they?  This is still up for debate and it'll only syntactic so don't change for now.

Without having member variables in affector arguments, we can't have an 'anchor' affector.  In fact, attached
weapons like this are difficult: if the Emitter is destroyed, we need to destroy its emitted objects, but the
current system is not set up for that.  This is important because there will be other uses for anchored objects.
	this is core functionality so shouldn't be left to a user-defined affector anyway.  need a way to tie
	emitter member variables to object variables/properties, and cope properly when the emitter dies before
	the object.

suspend/resume for states: suspend takes up to 8(?) values, and resume must pass all these values to resume
the state.  This way we can have combinational events.  However, this only works for controllers.  We would
need emitters to take events as well.  Emitters shouldn't take events, however, because any logic like this
should be done by controllers.

enable/disable emitters

events: events can take arguments.  Can be called in C++ code, in by states or other events by using syntax:
	raise Damaged(0.2); // etc

1) Implement affectors [DONE]

2) Implement controllers/events

3) Error-handling for everything that can cause an error

4) Once public interface is done, comment with doxygen

5) Optimise

	Get working with Threaded Building Blocks

	Check assembler output, look into SSE/2, look into compiler optimisations, intrinsic functions.

	Stack-register machine: abstract out all codegen/processing to a base VM class

	A FireTypeControl is needed for every FireType which has any kind of behaviour.  This could eat up memory.

	Cut down the number of arguments to interpretCode

	Avoid float-int conversions where possible - converting float to int is especially slow.
	
	Try to avoid strings at runtime (eg, passing a literal to a const ref invokes constructor)
	
	FireTypeBase::getPropertyIndex is bad, find a way round it (used in FireTypeBase set/get properties)
	
need to calculate memory usage if we're not going to allow custom allocators
	
need a way to release guns from memory pool, like firetypecontrols
	
What to do when user wants to manually control bullets from code?  Ie, when you fire a weapon,
the bullets stop their current behaviour and get sucked towards/blown away from you, and then
maybe resume their old behaviour when you stop firing.  This is an edge case but it must be considered.
	Guns should be able to relinquish control of their FireTypes, by calling "yield()" or similar.  When
	this is the case, all FireTypes do not have any special updating done (we have a pointer to the Gun
	in the FireTypeControl for checking).
