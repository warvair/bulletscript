suspend/resume for states: suspend takes up to 8(?) values, and resume must pass all these values to resume
the state.  This way we can have combinational events.  However, this only works for controllers.  We would
need emitters to take events as well.  Emitters shouldn't take events, however, because any logic like this
should be done by controllers.

Controller::setMember will not set emitter pos/angle correctly.
	interpretCode also just sets the member array directly.  Maybe we should disallow people from
	setting X/Y/Angle in script?  But let controllers set emitter x/y/angle.
	Issue is that x/y/angle are special members, but implemented as normals ones, which can slow down
	manipulating normal member vars.

controllers should be able to change emitter member vars smoothly, like properties.  this will allow
animation of emitters, eg moving gun position, or changing angle. $gun1.This_Angle = {45, 2};
	other issues with this, look into it.  also need to allow callbacks to user if driving emitters
	with controllers.
	Generally think about emitter member vars, how they're controlled, etc.

constant_expression needs to be able to take a member.var identifier, but only allow this in controller
events/states.  Check in semantic checking.

controller and emitter definitions may benefit from inheriting from a base class: cuts down on code.

1) Implement affectors [DONE]

2) Implement controllers/events

3) Once public interface is done, comment with doxygen

4) Optimise

	Get working with Threaded Building Blocks

	Check assembler output, look into SSE/2, look into compiler optimisations.

	Stack-register machine: abstract out all codegen/processing to a base VM class

	A FireTypeControl is needed for every FireType which has any kind of behaviour.  This could eat up memory.

	Cut down the number of arguments to interpretCode

	Avoid float-int conversions where possible
	
	FireTypeBase::getPropertyIndex is bad, find a way round it (used in FireTypeBase set/get properties)
	
	loop() may be inefficient because it requires checking and maintaining a loop struct.  It is used to
	loop a set number of times, but there may be a quicker way of implementing this.
	
need to calculate memory usage if we're not going to allow custom allocators
	
need a way to release guns from memory pool, like firetypecontrols
	
What to do when user wants to manually control bullets from code?  Ie, when you fire a weapon,
the bullets stop their current behaviour and get sucked towards/blown away from you, and then
maybe resume their old behaviour when you stop firing.  This is an edge case but it must be considered.
	Guns should be able to relinquish control of their FireTypes, by calling "yield()" or similar.  When
	this is the case, all FireTypes do not have any special updating done (we have a pointer to the Gun
	in the FireTypeControl for checking).
